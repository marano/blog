---
author: Flavia Fortes
hide_author_link: true
layout: post
title: "Performance Protips"
categories:
  - heroku
  - protips
  - postgresql
  - performance
  - rollbar
  - newrelic
  - english
  - flavia fortes

---

Hi, everyone!

This is my first post in English. A few weeks ago we received Ali to work with us as you can see [here](http://helabs.com.br/blog/2013/11/13/novos-membros-analu-e-ali/). Ali is from Azerbaijan and we only communicate in English. Now that we have him, we are trying our best to talk and write in English most of the time. And it's being an awesome experience. <3

So, inspired by this situation I decided that I would write the first English post on HE:labs blog. Let's see how it goes.


<!--more-->

I implemented on one of our projects here at HE:labs a sequence of complex calculations. After pushing these changes to the production environment, the website had lots of access which caused on an application error in Heroku. The complex calculations being generated by several users at the same time caused a server timeout.

As a programmer who is still learning how to code and how to deal with this kind of performance issues, I immediately saw an opportunity to grow. I asked help for more experienced programmers and now I'm gonna show you what I learned.

I discovered an amazing tool called [Rollbar](https://rollbar.com/) which catches errors and gives you information about it. This helps on discovering what happened and fixing it. It emails you whenever an exception occurs. This way, you can discover an error and fix it before your client calls you to warn you that some of his users complained. You anticipate that. Nice, uh?
After this lesson, I put Rollbar in all of my projects. And I truly can't see myself working in any project that doesn't have this kind of 24/7 analyzer. Here at HE:labs we also use [Airbrake](https://airbrake.io/) and we recommend it.

To put the rollbar add-on on your Heroku app:

{% highlight ruby linenos %}
  $ heroku addons:add rollbar --app yourapp
{% endhighlight %}

I also started to use [New Relic](http://newrelic.com/) to monitor app performance. It's another amazing tool that we recommend. If you don't know New Relic yet, it's a monitoring service which will watch your application health and availability and provide information about the root cause of app performance issues. In my case I was able to see which exactly were the queries that were taking so long to respond. They have these awesome graphics that show you which action or view needs some optimization.

To put the newrelic add-on on your Heroku app:

{% highlight ruby linenos %}
  $ heroku addons:add newrelic --app yourapp
{% endhighlight %}

The first thing I thought when the performance issue happened was that I would have to simulate the timeout on the staging environment. But to accomplish that I would have to clone the production database. I was using postgres on Heroku. That is what I have done and I will show this Heroku protip for you.

You are going to need the pg:backup add-on on both of your apps:

{% highlight ruby linenos %}
  $ heroku addons:add pgbackups
{% endhighlight %}

This next command line will create a database backup of your production app

{% highlight ruby linenos %}
  $ heroku pgbackups:capture --expire --app production-app
{% endhighlight %}

After this, you will use the pg:backups:restore on you staging app:

{% highlight ruby linenos %}
  $ heroku pgbackups:restore HEROKU_POSTGRESQL_TURQUOISE -a staging-app \
    `heroku pgbackups:url -a production-app`
{% endhighlight %}

Be aware of which color is the postgres database of your staging app, in this example was TURQUOISE.

In this particular case I also cloned the database to my local environment, like this:

After capturing the database shot, I downloaded it:

{% highlight ruby linenos %}
  $ curl -o latest.dump `heroku pgbackups:url`
{% endhighlight %}

And restored it locally:

{% highlight ruby linenos %}
  $ pg_restore --verbose --clean --no-acl --no-owner -h localhost -U youruser -d yourdb latest.dump
{% endhighlight %}


After all that, we had to do some refactoring. [Mauro](https://twitter.com/maurogeorge) did a lot of changes using Ruby Memoization and solving N+1 queries.
I can talk about that in the next post. What do you guys think? Let me know!

I hope this can help you in some manner and I expect to improve my English and come back writing soon enough.

Hugs!
